#!/usr/bin/env python3
"""
Build a single-file executable archive for ~ATH.

The resulting artifact is a Python zipapp that already contains all third-party
dependencies. Users only need a Python 3.9+ runtime on their machine.

Usage:
    python scripts/build_bundle.py

Optional flags:
    --api-key-file path/to/key.txt   # Injects key into generated launch wrapper
    --output-name NAME               # Change the name of the produced launcher

Outputs:
    dist/tildeath.pyz                # Executable zipapp
    dist/install_stub.sh             # One-line installer template
    dist/README.txt                  # Distribution notes for the bundle
"""

from __future__ import annotations

import argparse
import os
import shutil
import subprocess
import sys
import textwrap
from pathlib import Path


PROJECT_ROOT = Path(__file__).resolve().parents[1]
BUILD_ROOT = PROJECT_ROOT / ".build" / "zipapp"
APP_ROOT = BUILD_ROOT / "app"
DIST_ROOT = PROJECT_ROOT / "dist"

SOURCE_DIRS = [
    "engine",
    "config",
]

SOURCE_FILES = [
    "main.py",
    "test_visuals.py",
    "README.md",
    "QUICKSTART.md",
    "PROJECT_SUMMARY.md",
]


def run(cmd: list[str], cwd: Path | None = None) -> None:
    """Run a subprocess, surfacing errors."""
    subprocess.run(cmd, cwd=cwd, check=True)


def clean_previous_build() -> None:
    """Remove previous build artifacts."""
    if BUILD_ROOT.exists():
        shutil.rmtree(BUILD_ROOT)
    BUILD_ROOT.mkdir(parents=True)
    APP_ROOT.mkdir()
    DIST_ROOT.mkdir(exist_ok=True)


def install_dependencies(target: Path) -> None:
    """Install Python dependencies into the bundle staging directory."""
    requirements = PROJECT_ROOT / "requirements.txt"
    if not requirements.exists():
        raise FileNotFoundError("requirements.txt is missing.")

    run(
        [
            sys.executable,
            "-m",
            "pip",
            "install",
            "--upgrade",
            "--target",
            str(target),
            "-r",
            str(requirements),
        ]
    )


def copy_project_sources(target: Path) -> None:
    """Copy application sources into staging area."""
    for folder in SOURCE_DIRS:
        src = PROJECT_ROOT / folder
        dst = target / folder
        if dst.exists():
            shutil.rmtree(dst)
        shutil.copytree(src, dst)

    for filename in SOURCE_FILES:
        src = PROJECT_ROOT / filename
        if src.exists():
            shutil.copy2(src, target / src.name)


def write_entrypoint(target: Path) -> None:
    """Create __main__.py so the archive can be executed directly."""
    entrypoint = textwrap.dedent(
        """\
        # Auto-generated by scripts/build_bundle.py
        from main import main


        if __name__ == "__main__":
            main()
        """
    )
    (target / "__main__.py").write_text(entrypoint, encoding="utf-8")


def build_zipapp(source: Path, destination: Path) -> None:
    """Create the final zipapp executable."""
    run(
        [
            sys.executable,
            "-m",
            "zipapp",
            str(source),
            "-o",
            str(destination),
            "-p",
            "/usr/bin/env python3",
        ]
    )
    destination.chmod(0o755)


def write_install_stub(
    artifact_name: str,
    api_key: str | None,
) -> None:
    """Generate installer stub and distribution notes."""
    zipapp_url_placeholder = "<PUT_DOWNLOAD_URL_HERE>"
    default_install_path = "${HOME}/.ATH"
    if api_key:
        api_key_export = f'export ANTHROPIC_API_KEY="{api_key}"'
    else:
        api_key_export = '# export ANTHROPIC_API_KEY=your_shared_key_here'

    stub_contents = textwrap.dedent(
        f"""\
        #!/usr/bin/env bash
        #
        # Installer for ~ATH. Replace {zipapp_url_placeholder} with the hosted bundle URL.
        #
        set -euo pipefail

        ZIPAPP_URL="{zipapp_url_placeholder}"
        INSTALL_PATH="{default_install_path}"
        CACHE_DIR="${{HOME}}/.cache/tildeath"

        mkdir -p "$(dirname "$INSTALL_PATH")"
        mkdir -p "$CACHE_DIR"

        tmp_zip="$CACHE_DIR/{artifact_name}"

        echo "Downloading ~ATH..."
        curl -fsSL "$ZIPAPP_URL" -o "$tmp_zip"
        chmod +x "$tmp_zip"

        cat > "$INSTALL_PATH" <<'LAUNCHER'
        #!/usr/bin/env bash
        export ATH_HOME="${{ATH_HOME:-$HOME/.tildeath}}"
        mkdir -p "$ATH_HOME"
        cd "$ATH_HOME"
        {api_key_export}
        exec "$HOME/.cache/tildeath/{artifact_name}" "$@"
        LAUNCHER

        chmod +x "$INSTALL_PATH"

        echo "Installed ~ATH launcher at $INSTALL_PATH"
        echo "Run it with: $INSTALL_PATH"
        """
    )

    installer_path = DIST_ROOT / "install_stub.sh"
    installer_path.write_text(stub_contents, encoding="utf-8")
    installer_path.chmod(0o755)

    readme_text = textwrap.dedent(
        f"""\
        ~ATH Distribution Bundle
        ========================

        Files:
          - {artifact_name}    -> Executable zipapp (Python 3.9+ required)
          - install_stub.sh    -> Template installer script

        Recommended release workflow:
          1. Host {artifact_name} somewhere with HTTPS access (S3, GitHub release, etc.).
          2. Edit install_stub.sh, replacing the placeholder URL with the hosted file.
          3. (Optional) Put the Anthropic key into the launcher section if you want to share one.
          4. Share the one-liner installer:
               curl -fsSL <your-install-script-url> | bash

        After install, users can launch the game with:
            ~/.ATH

        The launcher stores runtime artifacts in $HOME/.tildeath and reuses the cached zipapp.
        """
    )
    (DIST_ROOT / "README.txt").write_text(readme_text, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build ~ATH distributable bundle.")
    parser.add_argument(
        "--api-key-file",
        type=Path,
        help="Optional file containing an Anthropic API key to embed into the launcher stub.",
    )
    parser.add_argument(
        "--output-name",
        default="tildeath.pyz",
        help="Name of the generated zipapp artifact (default: tildeath.pyz).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    api_key = None
    if args.api_key_file:
        if not args.api_key_file.exists():
            raise FileNotFoundError(f"API key file not found: {args.api_key_file}")
        api_key = args.api_key_file.read_text(encoding="utf-8").strip()

    clean_previous_build()
    install_dependencies(APP_ROOT)
    copy_project_sources(APP_ROOT)
    write_entrypoint(APP_ROOT)

    artifact_path = DIST_ROOT / args.output_name
    build_zipapp(APP_ROOT, artifact_path)

    write_install_stub(args.output_name, api_key)

    print(f"Bundle built at: {artifact_path}")
    print(f"Installer template: {DIST_ROOT / 'install_stub.sh'}")


if __name__ == "__main__":
    main()
